// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// V1Server v1 server
// swagger:model V1Server
type V1Server struct {

	// check
	Check *V1ServerCheck `json:"check,omitempty"`

	// framework
	Framework *V1ServerFramework `json:"framework,omitempty"`

	// Append arbitrary string to the "server" directive.
	MiscStr string `json:"miscStr,omitempty"`

	// port
	Port *V1ServerPort `json:"port,omitempty"`

	// task
	Task *V1ServerTask `json:"task,omitempty"`

	// type
	Type V1ServerType `json:"type,omitempty"`
}

func (m *V1Server) UnmarshalJSON(b []byte) error {
	type V1ServerAlias V1Server
	var t V1ServerAlias
	if err := json.Unmarshal([]byte("{\"check\":{},\"framework\":{},\"port\":{},\"task\":{},\"type\":\"AUTO_IP\"}"), &t); err != nil {
		return err
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}
	*m = V1Server(t)
	return nil
}

// Validate validates this v1 server
func (m *V1Server) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCheck(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFramework(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTask(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1Server) validateCheck(formats strfmt.Registry) error {

	if swag.IsZero(m.Check) { // not required
		return nil
	}

	if m.Check != nil {

		if err := m.Check.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("check")
			}
			return err
		}
	}

	return nil
}

func (m *V1Server) validateFramework(formats strfmt.Registry) error {

	if swag.IsZero(m.Framework) { // not required
		return nil
	}

	if m.Framework != nil {

		if err := m.Framework.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("framework")
			}
			return err
		}
	}

	return nil
}

func (m *V1Server) validatePort(formats strfmt.Registry) error {

	if swag.IsZero(m.Port) { // not required
		return nil
	}

	if m.Port != nil {

		if err := m.Port.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("port")
			}
			return err
		}
	}

	return nil
}

func (m *V1Server) validateTask(formats strfmt.Registry) error {

	if swag.IsZero(m.Task) { // not required
		return nil
	}

	if m.Task != nil {

		if err := m.Task.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("task")
			}
			return err
		}
	}

	return nil
}

func (m *V1Server) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := m.Type.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("type")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1Server) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1Server) UnmarshalBinary(b []byte) error {
	var res V1Server
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1ServerCheck Enable health checks. These are by default TCP health checks. For more options see "customCheck".
// These are required for DNS resolution (and hence VIPs) to function properly.
// swagger:model V1ServerCheck
type V1ServerCheck struct {

	// custom str
	CustomStr string `json:"customStr,omitempty"`

	// enabled
	Enabled *bool `json:"enabled,omitempty"`
}

func (m *V1ServerCheck) UnmarshalJSON(b []byte) error {
	type V1ServerCheckAlias V1ServerCheck
	var t V1ServerCheckAlias
	if err := json.Unmarshal([]byte("{\"enabled\":true}"), &t); err != nil {
		return err
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}
	*m = V1ServerCheck(t)
	return nil
}

// Validate validates this v1 server check
func (m *V1ServerCheck) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *V1ServerCheck) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1ServerCheck) UnmarshalBinary(b []byte) error {
	var res V1ServerCheck
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1ServerFramework The Mesos framework. If unsure, the value should probably be "marathon".
// swagger:model V1ServerFramework
type V1ServerFramework struct {

	// match
	Match V1Match `json:"match,omitempty"`

	// value
	Value string `json:"value,omitempty"`
}

func (m *V1ServerFramework) UnmarshalJSON(b []byte) error {
	type V1ServerFrameworkAlias V1ServerFramework
	var t V1ServerFrameworkAlias
	if err := json.Unmarshal([]byte("{\"match\":\"EXACT\"}"), &t); err != nil {
		return err
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}
	*m = V1ServerFramework(t)
	return nil
}

// Validate validates this v1 server framework
func (m *V1ServerFramework) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMatch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1ServerFramework) validateMatch(formats strfmt.Registry) error {

	if swag.IsZero(m.Match) { // not required
		return nil
	}

	if err := m.Match.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("framework" + "." + "match")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1ServerFramework) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1ServerFramework) UnmarshalBinary(b []byte) error {
	var res V1ServerFramework
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1ServerTask v1 server task
// swagger:model V1ServerTask
type V1ServerTask struct {

	// match
	Match V1Match `json:"match,omitempty"`

	// The Task name. This field is not needed for VIPs. For Marathon pods this is the container name NOT the pod name.
	Value string `json:"value,omitempty"`
}

func (m *V1ServerTask) UnmarshalJSON(b []byte) error {
	type V1ServerTaskAlias V1ServerTask
	var t V1ServerTaskAlias
	if err := json.Unmarshal([]byte("{\"match\":\"EXACT\"}"), &t); err != nil {
		return err
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}
	*m = V1ServerTask(t)
	return nil
}

// Validate validates this v1 server task
func (m *V1ServerTask) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMatch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1ServerTask) validateMatch(formats strfmt.Registry) error {

	if swag.IsZero(m.Match) { // not required
		return nil
	}

	if err := m.Match.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("task" + "." + "match")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1ServerTask) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1ServerTask) UnmarshalBinary(b []byte) error {
	var res V1ServerTask
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
